//Checks to see if there is a conflict with where a bike wants to move
class Conflicts {
	function int aConflict(int mem, int position, char direction){
		var int conflict, norm_pos, change_mem, x;
		let norm_pos = position;
		let conflict = 0;
		while (norm_pos > 15){ //normalizing the x position
			let norm_pos = norm_pos - 16;
		}
		if (norm_pos = 0){ //setting the posistion that the bike is in on the screen
			let norm_pos = 1;
		}
		if (norm_pos = 4){
			let norm_pos = 2;
		}
		if (norm_pos = 8){
			let norm_pos = 3;
		}
		if (norm_pos = 12){
			let norm_pos = 4;
		}
		if (direction = 114){ //checking conflicts while moving right
			let x = 16415;
			while (x < 24576){ //right wall
				if (mem = x){
					if (norm_pos = 4){
						let conflict = -1;
						return conflict;
					}
				}
				let x = x + 32;
			}
			if (norm_pos = 1){ //pos 1 to pos 2
				let conflict = Conflicts.oneAndTwoPositionConflict(mem);
			}
			if (norm_pos = 2){ //pos 2 to pos 3
				let conflict = Conflicts.twoAndThreePositionConflict(mem);
			}
			if (norm_pos = 3){ //pos 3 to pos 4
				let conflict = Conflicts.threeAndFourPositionConflict(mem);
			}
			if (norm_pos = 4){ //pos 4 to pos 1
				let change_mem = mem + 1;
				let conflict = Conflicts.onlyOnePositionConflict(change_mem);
			}
		}
		if (direction = 108){ //checking conflicts while moving left
			let x = 16384;
			while (x < 24576){ //left wall
				if (mem = x){
					if (norm_pos = 1){
						let conflict = -1;
						return conflict;
					}
				}
				let x = x + 32;
			}
			if (norm_pos = 1){  //pos 1 to pos 4
				let change_mem = mem - 1;
				let conflict = Conflicts.onlyFourPositionConflict(change_mem);
			}
			if (norm_pos = 2){ //pos 2 to pos 1
				let conflict = Conflicts.oneAndTwoPositionConflict(mem);
			}
			if (norm_pos = 3){ //pos 3 to pos 2
				let conflict = Conflicts.twoAndThreePositionConflict(mem);
			}
			if (norm_pos = 4){ //pos 4 to pos 3
				let conflict = Conflicts.threeAndFourPositionConflict(mem);
			}
		}
		if (direction = 117){ //checking conflicts while moving up
			let change_mem = mem - 128;
			let x = 16384;
			while (x < 16416){ //top wall
				if (mem = x){
					let conflict = -1;
					return conflict;
				}
				let x = x + 1;
			}
			if (norm_pos = 1){ //in pos 1
				let conflict = Conflicts.onlyOnePositionConflict(change_mem);
			}
			if (norm_pos = 2){ //in pos 2
				let conflict = Conflicts.onlyTwoPositionConflict(change_mem);
			}
			if (norm_pos = 3){ //in pos 3
				let conflict = Conflicts.onlyThreePositionConflict(change_mem);
			}
			if (norm_pos = 4){ //in pos 4
				let conflict = Conflicts.onlyFourPositionConflict(change_mem);
			}
		}
		if (direction = 100){ //checking conflicts while moving down
			let change_mem = mem + 128;
			let x = 24448;
			while (x < 24479){ //bottom wall
				if (mem = x){
					let conflict = -1;
					return conflict;
				}
				let x = x + 1;
			}
			if (norm_pos = 1){ //in pos 1
				let conflict = Conflicts.onlyOnePositionConflict(change_mem);
			}
			if (norm_pos = 2){ //in pos 2
				let conflict = Conflicts.onlyTwoPositionConflict(change_mem);
			}
			if (norm_pos = 3){ //in pos 3
				let conflict = Conflicts.onlyThreePositionConflict(change_mem);
			}
			if (norm_pos = 4){ //in pos 4
				let conflict = Conflicts.onlyFourPositionConflict(change_mem);
			}
		}
		return conflict;
	}

	//checks if there is a block in the first cell of given memory
	//checks all possible combinations in the memory cell with the first position filled
	function int onlyOnePositionConflict(int mem){
		var int conflict;
		let conflict = 0;
		if (Memory.peek(mem) = 15){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -4081){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 3855){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -241){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 255){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -3841){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 4095){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -1){
			let conflict = -1;
		}
		return conflict;
	}

	//checks if there is a block in the second cell of given memory
	//checks all possible combinations in the memory cell with the second position filled
	function int onlyTwoPositionConflict(int mem){
		var int conflict;
		let conflict = 0;
		if (Memory.peek(mem) = 255){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -3841){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 4095){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 240){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -3856){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 4080){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -16){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -1){
			let conflict = -1;
		}
		return conflict;
	}

	//checks if there is a block in the third cell of given memory
	//checks all possible combinations in the memory cell with the third position filled
	function int onlyThreePositionConflict(int mem){
		var int conflict;
		let conflict = 0;
		if (Memory.peek(mem) = 3855){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -241){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 4095){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 3840){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -256){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 4080){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -16){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -1){
			let conflict = -1;
		}
		return conflict;
	}

	//checks if there is a block in the fourth cell of given memory
	//checks all possible combinations in the memory cell with the fourth position filled
	function int onlyFourPositionConflict(int mem){
		var int conflict;
		let conflict = 0;
		if (Memory.peek(mem) = -4096){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -4081){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -256){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -241){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -3856){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -3841){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -16){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -1){
			let conflict = -1;
		}
		return conflict;
	}

	//checks if there is a block in the first or second cell of given memory
	//checks all possible combinations in the memory cell with the first and second positions filled
	function int oneAndTwoPositionConflict(int mem){
		var int conflict;
		let conflict = 0;
		if (Memory.peek(mem) = 255){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -3841){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 4095){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -1){
			let conflict = -1;
		}
		return conflict;
	}

	//checks if there is a block in the second or third cell of given memory
	//checks all possible combinations in the memory cell with the second and third positions filled
	function int twoAndThreePositionConflict(int mem){
		var int conflict;
		let conflict = 0;
		if (Memory.peek(mem) = 4095){
			let conflict = -1;
		}
		if (Memory.peek(mem) = 4080){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -16){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -1){
			let conflict = -1;
		}
		return conflict;
	}

	//checks if there is a block in the third or fourth cell of given memory
	//checks all possible combinations in the memory cell with the third and fourth positions filled
	function int threeAndFourPositionConflict(int mem){
		var int conflict;
		let conflict = 0;
		if (Memory.peek(mem) = -241){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -256){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -16){
			let conflict = -1;
		}
		if (Memory.peek(mem) = -1){
			let conflict = -1;
		}
		return conflict;
	}
}