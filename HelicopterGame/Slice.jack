class Slice {
  field int ceiling,floor;
  field int prev_ceiling,prev_floor;
  static int min_h, max_h;
  static int block_size;
  static int min_gap;

  constructor Slice new(int C, int F) {
    let block_size = 12;
    let min_h = 20;
    let max_h = 236;
    let min_gap = block_size * 14;
    let prev_ceiling = min_h;
    let prev_floor = max_h;
    let ceiling = min_h + (C * block_size);
    let floor = max_h - (F * block_size);
    return this;
  }

  // draw the difference between this slice and the
  // previous slice given an x-coordinate
  method void draw(int x) {
    if (~(ceiling = prev_ceiling)) {
      if (prev_ceiling < ceiling) {
        do Screen.setColor(true);
        do Screen.drawRectangle(x,prev_ceiling,x+block_size-1,ceiling);
      } else {
        do Screen.setColor(false);
        do Screen.drawRectangle(x,ceiling,x+block_size-1,prev_ceiling);
      }
    }
    if (~(floor = prev_floor)) {
      if (prev_floor > floor) {
        do Screen.setColor(true);
        do Screen.drawRectangle(x,floor,x+block_size-1,prev_floor);
      } else {
        do Screen.setColor(false);
        do Screen.drawRectangle(x,prev_floor,x+block_size-1,floor);
      }
    }
    return;     
  }

  // update with the paramaters for the previous slice
  method void update(Slice previous) {
    let prev_ceiling = previous.ceiling();
    let prev_floor = previous.floor();
    return;
  }

  // modify this slice based on the previous slice,
  // wall and ceiling can change by -1,0,1 blocks
  method void build_from(Slice previous) {
    var int r1,r2;
    var int c,f;
    let r1 = Random.between(-1,2) * block_size;
    let r2 = Random.between(-1,2) * block_size;
    let c = previous.ceiling();
    let f = previous.floor();
    if (((c + r1) > (min_h - 1)) & ((c + r1 + 1) > min_h)) {
      let ceiling = c + r1;
    } else {
      let ceiling = c;
    }
    if (((ceiling + min_gap - 1) < (f + r2)) & ((f + r2 - 1) < max_h)) {
      let floor = f + r2;
    } else {
      let floor = f;
    }
    // if the gap is too small, reset to maximum,
    // (so we don't get stuck in a long, narrow tunnel)
    if ((floor - ceiling) < min_gap) {
      let floor = max_h;
      let ceiling = min_h;
    }
    return;
  }

  // check to see if the helicopter is between the floor and the ceiling
  method boolean in_slice(int top, int bottom) {
    var boolean valid;
    if ((top > ceiling) & (bottom < floor)) {
      let valid = true;
    } else {
      let valid = false;
    }
    return valid;
  }

  // reduce the minimum gap between the floor and ceiling
  method void shrink() {
    if ((min_gap+1) > (block_size*5)) {
      let min_gap = min_gap - block_size;
    }
    return;
  }

  method int ceiling() {
    return ceiling;
  }

  method int floor() {
    return floor;
  }
 
  method void dispose() {
    do Memory.deAlloc(this);
    return;
  }

}