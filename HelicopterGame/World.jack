class World {
  field Array slices;
  field int block_size;
  field int screen_width, screen_height;
  field int slices_on_screen, number_of_slices;
  field int leftmost_slice,hidden_slice;
  field int draw_counter;
  field int distance;
  
  constructor World new() {
    let screen_width = 504;
    let screen_height = 256;
    let block_size = 12;
    let slices_on_screen = 42;
    let number_of_slices = slices_on_screen + 1;
    do reset();
    do create_slices();
    return this;
  }

  // either draw all the slices, generate a new one,
  // or shift all slices (redrawing each time this
  // function is called would make the world scroll to fast)
  method void draw() {
    if (draw_counter = 0) {
      do draw_slices();
    } else {
      if (draw_counter = 1) {
        do create_new_slice();
      } else {
        if (draw_counter = 2) {
          do shift_slices();
        } else {
          if (draw_counter = 3) {
            do update_slices();
          }
        }
      }
    }
    let draw_counter = Random.mod(draw_counter + 1,4);
    return;
  }

  // draw all the slices that fit on the screen
  method void draw_slices() {
    var int x,l;
    var Slice s;
    let x = 0;
    let l = leftmost_slice;
    while (x < screen_width) {
      let s = slices[l];
      do s.draw(x);
      let x = x + block_size;
      let l = l + 1;
      let l = Random.mod(l,number_of_slices);
    }
    return;
  }

  // tell each slice about the slice over which
  // they'll be drawing in the next frame
  method void update_slices() {
    var Slice s,p;
    var int i,j,k;
    let i = 0;
    let j = leftmost_slice;
    let k = hidden_slice;
    while (i < slices_on_screen) {
      let p = slices[k];
      let s = slices[j];
      do s.update(p);
      let i = i + 1;
      let j = Random.mod(j+1,number_of_slices);
      let k = Random.mod(k+1,number_of_slices);
    }
    return;
  }

  // move the index to the circular array
  method void shift_slices() {
    let hidden_slice = leftmost_slice;
    let leftmost_slice = Random.mod(leftmost_slice+1,number_of_slices);
    let distance = distance + 1;
    return;
  }

  // modify the slice in the hidden slot
  method void create_new_slice() {
    var Slice h,p;
    var int prev;
    let h = slices[hidden_slice];
    let prev = Random.mod(hidden_slice - 1,number_of_slices);
    let p = slices[prev];
    do h.build_from(p);
    return;
  }

  // check for a collision between the helicopter and the slices
  method boolean collision(int top, int bottom) {
    var boolean collision;
    var Slice A,B,C,D;
    let collision = true;
    let A = slices[Random.mod( 8 + leftmost_slice,number_of_slices)];
    let B = slices[Random.mod( 9 + leftmost_slice,number_of_slices)];
    let C = slices[Random.mod(10 + leftmost_slice,number_of_slices)];
    let D = slices[Random.mod(11 + leftmost_slice,number_of_slices)];
    if ((A.in_slice(top,bottom)) & (B.in_slice(top,bottom)) & (C.in_slice(top,bottom)) & (D.in_slice(top,bottom))) {
      let collision = false;
    }
    return collision;
  }

  // shrink the space between ceiling and floor
  // (but only do so once per drawing cycle)
  method void shrink() {
    var Slice h;
    if (draw_counter = 3) {
      let h = slices[hidden_slice];
      do h.shrink();
    }
    return;
  }

  // reset the world variables
  method void reset() {
    let leftmost_slice = 0;
    let hidden_slice = number_of_slices - 1;
    let draw_counter = 0;
    let distance = 0;
    do create_slices();
    do draw();
    return;
  }


  // setup the initial slices
  method void create_slices() {
    let slices = Array.new(number_of_slices);
     let slices[0] = Slice.new(0,1);
     let slices[1] = Slice.new(1,1);
     let slices[2] = Slice.new(1,0);
     let slices[3] = Slice.new(1,1);
     let slices[4] = Slice.new(0,1);
     let slices[5] = Slice.new(1,1);
     let slices[6] = Slice.new(1,0);
     let slices[7] = Slice.new(1,1);
     let slices[8] = Slice.new(0,1);
     let slices[9] = Slice.new(1,1);
    let slices[10] = Slice.new(1,0);
    let slices[11] = Slice.new(1,1);
    let slices[12] = Slice.new(0,1);
    let slices[13] = Slice.new(1,1);
    let slices[14] = Slice.new(1,0);
    let slices[15] = Slice.new(1,1);
    let slices[16] = Slice.new(0,1);
    let slices[17] = Slice.new(1,1);
    let slices[18] = Slice.new(1,0);
    let slices[19] = Slice.new(1,1);
    let slices[20] = Slice.new(0,1);
    let slices[21] = Slice.new(1,1);
    let slices[22] = Slice.new(1,0);
    let slices[23] = Slice.new(1,1);
    let slices[24] = Slice.new(0,1);
    let slices[25] = Slice.new(1,1);
    let slices[26] = Slice.new(1,0);
    let slices[27] = Slice.new(1,1);
    let slices[28] = Slice.new(0,1);
    let slices[29] = Slice.new(1,1);
    let slices[30] = Slice.new(1,0);
    let slices[31] = Slice.new(1,1);
    let slices[32] = Slice.new(1,0);
    let slices[33] = Slice.new(1,1);
    let slices[34] = Slice.new(0,1);
    let slices[35] = Slice.new(1,1);
    let slices[36] = Slice.new(1,0);
    let slices[37] = Slice.new(1,1);
    let slices[38] = Slice.new(0,1);
    let slices[39] = Slice.new(1,1);
    let slices[40] = Slice.new(1,0);
    let slices[41] = Slice.new(1,1);
    let slices[42] = Slice.new(1,0);
    return;
  }

  method int distance() {
    return distance;
  }

  method void dispose() {
    do Memory.deAlloc(this);
    return;
  }
}

