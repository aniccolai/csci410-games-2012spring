class Board {
    field Array tiles;
    field boolean  _hasMineBeenRevealed;
    field int cursorX, cursorY;
    field int height, width;
    field int mineCount, unrevealedTileCount;
    
    constructor Board new(int w, int h, int _mineCount) {
        var int x, y, i;
        var Array col;
        var Tile temp;
        var Random rng;
  
        let width = w;
        let height = h;
        let cursorX = 0;
        let cursorY = 0;
        let _hasMineBeenRevealed = false;
        let tiles = Array.new(w);
        let mineCount = _mineCount;
        let unrevealedTileCount = w * h;

        let x = 0;
        while (x < w) {
            let col = Array.new(h);
            let tiles[x] = col;

            let y = 0;
            while (y < h) {
                let col[y] = Tile.new(x, y, this);
                let y = y + 1;
            }
            
            let x = x + 1;
        }
        
        //TODO: assign mines
        let rng = Random.new(Start.getSeed());
        
        while (i < mineCount) {
            let x = rng.nextRange(0, width);
            let y = rng.nextRange(0, height);
            let temp = tileAt(x, y);
            
            if (~temp.isMine()) {
                do temp.setIsMine(true);
                let i = i + 1;
            }
        }
                
        return this;
    }
    
    method Tile tileAt(int x, int y) {
        var Tile tile;
        var Array column;
        
        let column = tiles[x];
        let tile = column[y];
        
        return tile;
    }
    
    method boolean hasMineBeenRevealed() { return _hasMineBeenRevealed; }
    method int getUnrevealedTileCount() { return unrevealedTileCount; }
    method void decrementUnrevealedTileCount() { let unrevealedTileCount = unrevealedTileCount - 1; return; }
    method int getMineCount() { return mineCount; }
    method int getHeight() { return height; }
    method int getWidth()  { return width;  }
    method int getCursorX() { return cursorX; }
    method int getCursorY() { return cursorY; }
    
    /**
     * Reveal tile located under cursor
     */
    method void revealTileAtCursor() {
        var Tile tile;
        let tile = tileAt(cursorX, cursorY);

        do revealTile(tile);

        return;
    }
    
    method void revealTile(Tile tile) {
        if (~tile.hasBeenRevealed()) {
            do tile.reveal(); //draws the tile value!
            
            if (tile.isMine()) {
                let _hasMineBeenRevealed = true;
            }
            else {
                if (adjacentMineCount(tile) = 0) {
                    do scanForAdjacentZeroes();
                }
            }
        }

        return;
    }
    
    method void scanForAdjacentZeroes() {
        var boolean hasTileBeenFlipped;
        var int x, y;
        var Tile temp;
        
        let hasTileBeenFlipped = true;
        
        while (hasTileBeenFlipped) {
            let hasTileBeenFlipped = false;
            let x = 0;
            
            while (x < width) {
                let y = 0;
                
                while (y < height) {
                    let temp = tileAt(x, y);
                    
                    if (hasRevealedZeroNeighbor(temp) & (~temp.hasBeenRevealed())) {
                        let hasTileBeenFlipped = true;
                        do temp.reveal();
                    }
                    
                    let y = y + 1;
                }
                
                let x = x + 1;
            }   
        }
        
        return;
    }

    method void toggleFlagAtCursor() {
        var Tile tile;
        let tile = tileAt(cursorX, cursorY);

        do tile.toggleIsFlag();

        return;
    }
    
    method int adjacentMineCount(Tile tile) {
        var int count, x, y;
        var Tile temp;

        if (tile.isMine()) {
            return -1;
        }

        let x = tile.getX();
        let y = tile.getY();
        let count = 0;
        
        if ((x > 0) & (y > 0)) {
            let temp = tileAt(x - 1, y - 1);
            if (temp.isMine()) {
                let count = count + 1;
            }
        }

        if (x > 0) {
            let temp = tileAt(x - 1, y);
            if (temp.isMine()) {
                let count = count + 1;
            }
        }

        if ((x > 0) & (y < (height - 1))) {
            let temp = tileAt(x - 1, y + 1);
            if (temp.isMine()) {
                let count = count + 1;
            }
        }

        if (y > 0) {
            let temp = tileAt(x, y - 1);
            if (temp.isMine()) {
                let count = count + 1;
            }
        }

        // x, y is current tile, don't count
        
        if (y < (height - 1)) {
            let temp = tileAt(x, y + 1);
            if (temp.isMine()) {
                let count = count + 1;
            }
        }

        if ((x < (width - 1)) & (y > 0)) {
            let temp = tileAt(x + 1, y - 1);
            if (temp.isMine()) {
                let count = count + 1;
            }
        }

        if (x < (width - 1)) {
            let temp = tileAt(x + 1, y);
            if (temp.isMine()) {
                let count = count + 1;
            }
        }

        if ((x < (width - 1)) & (y < (height - 1))) {
            let temp = tileAt(x + 1, y + 1);
            if (temp.isMine()) {
                let count = count + 1;
            }
        }
        
        return count;
    }
    
    method int hasRevealedZeroNeighbor(Tile tile) {
        var int x, y;
        var Tile temp;
        var boolean found;
        
        let found = false;
        let x = tile.getX();
        let y = tile.getY();
        
        if ((x > 0) & (y > 0)) {
            let temp = tileAt(x - 1, y - 1);
            
            if (temp.hasBeenRevealed()) {
                if (adjacentMineCount(temp) = 0) {
                    let found = true;
                }
            }
        }

        if (x > 0) {
            let temp = tileAt(x - 1, y);
            
            if (temp.hasBeenRevealed()) {
                if (adjacentMineCount(temp) = 0) {
                    let found = true;
                }
            }
        }

        if ((x > 0) & (y < (height - 1))) {
            let temp = tileAt(x - 1, y + 1);
            
            if (temp.hasBeenRevealed()) {
                if (adjacentMineCount(temp) = 0) {
                    let found = true;
                }
            }
        }

        if (y > 0) {
            let temp = tileAt(x, y - 1);
            
            if (temp.hasBeenRevealed()) {
                if (adjacentMineCount(temp) = 0) {
                    let found = true;
                }
            }
        }

        // x, y is current tile, don't count
        
        if (y < (height - 1)) {
            let temp = tileAt(x, y + 1);
            
            if (temp.hasBeenRevealed()) {
                if (adjacentMineCount(temp) = 0) {
                    let found = true;
                }
            }
        }

        if ((x < (width - 1)) & (y > 0)) {
            let temp = tileAt(x + 1, y - 1);
            
            if (temp.hasBeenRevealed()) {
                if (adjacentMineCount(temp) = 0) {
                    let found = true;
                }
            }
        }

        if (x < (width - 1)) {
            let temp = tileAt(x + 1, y);
            
            if (temp.hasBeenRevealed()) {
                if (adjacentMineCount(temp) = 0) {
                    let found = true;
                }
            }
        }

        if ((x < (width - 1)) & (y < (height - 1))) {
            let temp = tileAt(x + 1, y + 1);
            
            if (temp.hasBeenRevealed()) {
                if (adjacentMineCount(temp) = 0) {
                    let found = true;
                }
            }
        }
        
        return found;
    }
    
    /* cursor movement:
     *      if movement is possible:
     *          erase cursor
     *          adjust location
     *          draw cursor
     */
        
    method void moveCursorUp() {
        do Drawing.eraseCursor(cursorX, cursorY);
    
        if (cursorY > 0) {
            let cursorY = cursorY - 1;
        }
        
        do Drawing.drawCursor(cursorX, cursorY);
        
        return;
    }
    
    method void moveCursorDown() {
        do Drawing.eraseCursor(cursorX, cursorY);
        
        if (cursorY < (height - 1)) {
            let cursorY = cursorY + 1;
        }
        
        do Drawing.drawCursor(cursorX, cursorY);
        
        return;
    }
    
    method void moveCursorLeft() {
        do Drawing.eraseCursor(cursorX, cursorY);
        
        if (cursorX > 0) {
            let cursorX = cursorX - 1;
        }
        
        do Drawing.drawCursor(cursorX, cursorY);
    
        return;
    }
    
    method void moveCursorRight() {
        do Drawing.eraseCursor(cursorX, cursorY);
        
        if (cursorX < (width - 1)) {
            let cursorX = cursorX + 1;
        }
        
        do Drawing.drawCursor(cursorX, cursorY);
        
        return;
    }
}