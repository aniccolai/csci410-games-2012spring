class Mortle {
	field FixedPoint x, y;
	//x pos right
	//y pos down
	field FixedPoint velX, velY;
	//velX pos right
	//velY pos up
	field Level level;
	field FixedPoint accel;
	constructor Mortle new(FixedPoint x0, FixedPoint y0,
		FixedPoint velX0, FixedPoint velY0, Level curLevel) {
		let x = x0;
		let y = y0;
		let velX = velX0;
		let velY = velY0;
		let level = curLevel;
		let accel = FixedPoint.new(0,3,true);
		return this;
	}

	method void dispose() {
		do velX.dispose();
		do velY.dispose();
		do x.dispose();
		do y.dispose();
		do accel.dispose();
		do Memory.deAlloc(this);
		return;
	}

	method void launch() {
		do level.draw();
		while(true) {
			//if the block in the direction of the current velocity is present, bounce
			if(level.isBlockAt((x.round()+(velX.getSign()*2)+1), y.round())) {
				do velX.negateEq();
			}
			if(~velY.getSign()) {
				if(level.isBlockAt(x.round(),(y.round()-1))) {
					do velX.dispose();
					do velY.dispose();
					let velX = FixedPoint.new(0,0,false);
					let velY = FixedPoint.new(0,0,false);
				}
			}
			do x.addEq(velX);
			do y.subEq(velY);
			if(level.isBlockAt(x.round(), y.round())) {
				do x.subEq(velX);
				do y.addEq(velY);
				do level.draw();
				return;
			}
			do Screen.drawPixel(x.round(), y.round());
			do Sys.wait(5);
			do velY.addEq(accel);
		}
		return;
	}

	method int getX(){
		return x.round();
	}

	method int getY(){
		return (y.round()/16)*16+15;
	}



}
