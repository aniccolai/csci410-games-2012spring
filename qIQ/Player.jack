class Player{
	// coordinates refer to the top left corner of player's square
	field int x;
	field int y;
	field int origX;
	field int origY;
	field int score;
	field int speed;
	field boolean assassin;
	field boolean border;
	field int size;
	
	// Constructor for Player. Takes two inputs, int corrdX and int coordY. Initializes all variables. 
	constructor Player new(int coordX, int coordY){
		let x = coordX;
		let y = coordY;
		let origX = x;
		let origY = y;
		let score = 0;
		let assassin = 0;
		let speed = 1;
		let size = 5;
		let border = false;
		return this;
	}
	
	// Getters and setters. 
	method int getX(){
		return x;
	}
	method int getY(){
		return y;
	}
	method int getScore(){
		return score;
	} 
	method void setAssassin(boolean turn){
		let assassin = turn;
		return;
	}
	
	method int getSize(){
		return size;
	}
	
	method void setSize(int newSize){
		let size = newSize;
		return;
	}
	
	method void setSpeed(int newSpeed){
		let speed = newSpeed;
		return;
	}

	// socreInc method. Takes no inputs. Increments the score for which ever player. 
	method void scoreInc(){
		let score = score + 1;
		return;
	}
	
	// isAssassin method. takes no inputs. determines if player is assassin. 
	method boolean isAssassin(){
		return assassin;
	}
	
	// onBorder method. takes no inputs. determines if a player in on the boarder of the screen. 
	method boolean onBorder(){
		return border;
	}
	
	// drawPlayer method. takes one input, boolean color. Draws the each player with specified color (black). 
	method void drawPlayer(boolean color){
		var int lastRow;
		var int lastCol;
		do Screen.setColor(color);
		let lastRow = x + size;
		let lastCol = y + size;
		do Screen.drawRectangle(x,y,lastRow,lastCol);
		do Screen.setColor(true);
		return;
	}
	
	// resetPosition method. takes no inputs. Draws the players at the starting locations for the beggining of each round. 
	method void resetPosition(){
	//method void resetPosition(int newSize){
		do drawPlayer(false);
		let x = origX;
		let y = origY;
		//do setSize(newSize);
		do drawPlayer(true);
		return;
	}
	
	// refreshPosition method. Takes one input, int direction. This erases and redraws each player as it is moving given the direction. 
	method void refreshPosition(int direction){
	
		if(direction = 0){ // for when not moving
			let border = true;
			return;
		}if((direction = 1) & ((y-speed) < 21)){ // if up and against top border
			let border = true;
			return;
		}if((direction = 2) & (y = (255-size))){ // if down and at bottom of border
			let border = true;
			return;
		}if((direction = 3) & ((x-speed) < 1)){ // if left and against left border
			let border = true;
			return;
		}if((direction = 4) & (x = (511-size))){ // if right and agains right border
			let border = true;
			return;
		}
		let border = false;
		
		do Screen.setColor(false);
		if(direction = 1){		 // up
			do Screen.drawRectangle(x,y+size,x+size,y+size);
			do Screen.setColor(true);
			let y = y - speed;
			do Screen.drawRectangle(x,y,x+size,y);
			return;
		}
		if(direction = 2){ // down
			do Screen.drawRectangle(x,y,x+size,y);
			do Screen.setColor(true);
			let y = y + speed;
			do Screen.drawRectangle(x,y+size,x+size,y+size);
			return;
		}
		if(direction = 3){ // left
			do Screen.drawRectangle(x+size,y,x+size,y+size);
			do Screen.setColor(true);
			let x = x - speed;
			do Screen.drawRectangle(x,y,x,y+size);
			return;
		}
		if(direction = 4){	 // right
			do Screen.drawRectangle(x,y,x,y+size);
			do Screen.setColor(true);
			let x = x + speed;
			do Screen.drawRectangle(x+size,y,x+size,y+size);
			return;
		}
		return;
		
	}

	// disitegrate method. takes no inputs. this animates the "death" of the caught player. 
	method void disintegrate(){
		var int row;
		let row = y;
		do Screen.setColor(false);
		while(row < (y+size+1)){
			do Screen.drawRectangle(x,row,x+size,row);
			let row = row + 1;
			do Sys.wait(100);
		}
		do Screen.setColor(true);
		return;
	}
	
	// checkCollision method. takes one input, a Player p2 object. This checks to see if one player has collided with another player. 
	method boolean checkCollision(Player p2){
		
		if((p2.getY()+p2.getSize()) = y){ 			// top of p1 and bottom of p2
			if((x<p2.getX()) & (p2.getX() < (x+size))){
				return true;
			}
			if((x<(p2.getX()+p2.getSize())) & ((p2.getX()+p2.getSize()) < (x+size))){
				return true;
			}
			if((x = p2.getX()) | ((x+size) = p2.getX())){
				return true;
			}
		}
		if( p2.getY() = (y+size)){ 				    // bottom of p1 and top of p2
			if((x<p2.getX()) & (p2.getX() < (x+size))){
				return true;
			}
			if((x<(p2.getX()+p2.getSize())) & ((p2.getX()+p2.getSize()) < (x+size))){
				return true;
			}
			if((x = p2.getX()) | ((x+size) = p2.getX())){
				return true;
			}	
		}
		if((p2.getX()) = (x+size)){ 			// right side p1, left side p2
			if((y<p2.getY()) & (p2.getY() < (y+size))){
				return true;
			}
			if((y<(p2.getY()+p2.getSize())) & ((p2.getY()+p2.getSize()) < (y+size))){
				return true;
			}
			if((y = p2.getY()) | ((y+size) = p2.getY())){
				return true;
			}
		}
		if((p2.getX()+p2.getSize()) = x){ 			// left of p1, right of p2
			if((y<p2.getY()) & (p2.getY() < (y+size))){
				return true;
			}
			if((y<(p2.getY()+p2.getSize())) & ((p2.getY()+p2.getSize()) < (y+size))){
				return true;
			}
			if((y = p2.getY()) | ((y+size) = p2.getY())){
				return true;
			}
		}
		return false;
	}
	
}